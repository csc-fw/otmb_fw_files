///////////////////////////////////////////////////////////////////////////////
//   ____  ____
//  /   /\/   /
// /___/  \  /    Vendor: Xilinx 
// \   \   \/     Version : 1.8
//  \   \         Application : Virtex-6 FPGA GTX Transceiver Wizard
//  /   /         Filename : rx_sync.v
// /___/   /\     Timestamp :
// \   \  /  \ 
//  \___\/\___\
//
//
// Module RX_SYNC
// Generated by Xilinx Virtex-6 FPGA GTX Transceiver Wizard
// 
// 
// (c) Copyright 2009-2010 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES. 


`timescale 1ns / 1ps
`define DLY #1

module GTX_RX_SYNC 
(
    output          RXENPMAPHASEALIGN,
    output          RXPMASETPHASE,
    output          RXDLYALIGNDISABLE,
    output          RXDLYALIGNOVERRIDE,
    output          RXDLYALIGNRESET,
    output          SYNC_DONE,
    input           USER_CLK,
    input           RESET

);


//*******************************Register Declarations************************

    reg            begin_r;
    reg            phase_align_r;
    //* max_fanout = 2 *
    reg            ready_r;
    reg   [5:0]    sync_counter_r;
    reg   [5:0]    sync_done_count_r;
    reg   [4:0]    align_reset_counter_r;
    reg            wait_after_sync_r;
    reg   [5:0]    wait_before_setphase_counter_r;
    reg            wait_before_setphase_r;
    reg            align_reset_r;
    
//*******************************Wire Declarations****************************
    
    wire           count_32_setphase_complete_r;
    wire           count_32_wait_complete_r;
    wire           count_align_reset_complete_r;
    wire           next_phase_align_c;
    wire           next_align_reset_c;    
    wire           next_ready_c;
    wire           next_wait_after_sync_c;
    wire           next_wait_before_setphase_c;
    wire           sync_32_times_done_r;

//*******************************Main Body of Code****************************

    //________________________________ State machine __________________________    
    // This state machine manages the phase alingment procedure of the GTX on the
    // receive side. The module is held in reset till the usrclk source is stable
    // and RXRESETDONE is asserted. In the case that a MMCM is used to generate 
    // rxusrclk, the mmcm_locked signal is used to indicate a stable usrclk source.
    // Once the RXRESETDONE and mmcm_locked is asserted, the state machine goes 
    // into the align_reset_r for 20 cycles. After this, it goes into the 
    // wait_before_setphase_r state for 32 cycles. After asserting PHASEALIGN 
    // and waiting 32 cycles, it enters the phase_align_r state where RXPMASETPHASE 
    // is asserted for 32 clock cycles. After the port is deasserted, the state 
    // machine goes into a wait state for 32 cycles. This procedure is repeated 32 times.
    
    // State registers
    always @(posedge USER_CLK)
        if(RESET)
            {begin_r,align_reset_r,wait_before_setphase_r,phase_align_r,wait_after_sync_r,ready_r}  <=  `DLY    6'b100000;
        else
        begin
            begin_r                <=  `DLY    1'b0;
            align_reset_r          <=  `DLY    next_align_reset_c;
            wait_before_setphase_r <=  `DLY    next_wait_before_setphase_c;
            phase_align_r          <=  `DLY    next_phase_align_c;
            wait_after_sync_r      <=  `DLY    next_wait_after_sync_c;
            ready_r                <=  `DLY    next_ready_c;
        end

    // Next state logic                        
    assign  next_align_reset_c          =   begin_r |
                                            (align_reset_r & !count_align_reset_complete_r);
                                        
    assign  next_wait_before_setphase_c =   (align_reset_r & count_align_reset_complete_r) |
                                            (wait_before_setphase_r & !count_32_wait_complete_r);
                                        
    assign  next_phase_align_c          =   (wait_before_setphase_r & count_32_wait_complete_r) |
                                            (phase_align_r & !count_32_setphase_complete_r) |
                                            (wait_after_sync_r & count_32_wait_complete_r & !sync_32_times_done_r);
                                        
    assign  next_wait_after_sync_c      =   (phase_align_r & count_32_setphase_complete_r) |
                                            (wait_after_sync_r & !count_32_wait_complete_r);

    assign  next_ready_c                =   (wait_after_sync_r & count_32_wait_complete_r & sync_32_times_done_r) |
                                            ready_r;



    //______ Counter for holding RXDLYALIGNRESET for 20 RXUSRCLK2 cycles ______
    always @(posedge USER_CLK)
    begin
        if (!align_reset_r)
            align_reset_counter_r <= `DLY 5'b00000;
        else
            align_reset_counter_r <= `DLY align_reset_counter_r +1'b1;
    end

    assign count_align_reset_complete_r = align_reset_counter_r[4]
                                        & align_reset_counter_r[2];

    //_______ Counter for waiting 32 clock cycles before TXPMASETPHASE ________
    always @(posedge USER_CLK)
    begin
        if (!wait_before_setphase_r && !wait_after_sync_r)
            wait_before_setphase_counter_r <= `DLY  6'b000000;
        else
            wait_before_setphase_counter_r <= `DLY  wait_before_setphase_counter_r + 1'b1;
    end

    assign count_32_wait_complete_r = wait_before_setphase_counter_r[5];

    //_______________ Counter for holding SYNC for SYNC_CYCLES ________________
    always @(posedge USER_CLK)
    begin
        if (!phase_align_r)
            sync_counter_r <= `DLY  6'b000000;
        else
            sync_counter_r <= `DLY  sync_counter_r + 1'b1;
    end

    assign count_32_setphase_complete_r = sync_counter_r[5];

    //__________ Counter for counting number of times sync is done ____________
    always @(posedge USER_CLK)
    begin
        if (RESET)
            sync_done_count_r <= `DLY  6'b000000;
        else if(count_32_wait_complete_r && phase_align_r)
            sync_done_count_r <= `DLY  sync_done_count_r + 1'b1;
    end

    assign sync_32_times_done_r = sync_done_count_r[5];

    //_______________ Assign the phase align ports into the GTX _______________

//    assign RXDLYALIGNRESET    = align_reset_r; // JRG, was 1'b0;
    assign RXDLYALIGNRESET    = 1'b0;

    assign RXENPMAPHASEALIGN  = !begin_r & !align_reset_r;
    assign RXPMASETPHASE      = phase_align_r;

//    assign RXDLYALIGNDISABLE  = begin_r | ready_r; // JRG, does this even work?  was 1'b0. 
//    assign RXDLYALIGNDISABLE  = 1'b1; // begin_r | ready_r; // JRG, is this best?  was 1'b0. 
    assign RXDLYALIGNDISABLE  = 1'b0; // Xilinx does not recommend this, but it was set to this...

//    assign RXDLYALIGNOVERRIDE = 1'b1; // JGhere, used to be 1'b0, set it to 1 for rx_dlyalign testing
    assign RXDLYALIGNOVERRIDE = 1'b0; // JGhere, used to be hardcoded 1'b0 at upper level, disables rx_dlyalign

    //_______________________ Assign the sync_done port _______________________

    assign SYNC_DONE = ready_r;

endmodule
